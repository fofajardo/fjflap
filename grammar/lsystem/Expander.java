/* -- JFLAP 4.0 --
 *
 * Copyright information:
 *
 * Susan H. Rodger, Thomas Finley
 * Computer Science Department
 * Duke University
 * April 24, 2003
 * Supported by National Science Foundation DUE-9752583.
 *
 * Copyright (c) 2003
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the author.  The name of the author may not be used to
 * endorse or promote products derived from this software without
 * specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
 
package grammar.lsystem;

import java.util.*;

/**
 * Given an L-system, this will expand the L-system, creating the vast
 * lists of symbols generated by successive expansions of the
 * L-system.
 * 
 * @author Thomas Finley
 */

public class Expander {
    /**
     * Instantiates a new expander, with a randomly selected random
     * seed used for resolving ambiguity.
     * @param lsystem the lsystem to make an expander for
     */
    public Expander(LSystem lsystem) {
	this(lsystem, RANDOM.nextLong());
    }

    /**
     * Instantiates a new expander, with a specified random seed.
     * @param lsystem the lsystem to make an expander for
     * @param seed the seed for the randomizer
     */
    public Expander(LSystem lsystem, long seed) {
	stochiastic = new Random(seed);
	this.lsystem = lsystem;
	cachedExpansions.add(lsystem.getAxiom());
    }

    /**
     * Returns the expansion at a given level of recursion.  An input
     * of 0 will return the axiom (i.e., no replacement or recursion
     * has occurred).
     * @param level the level of recursion to sink to
     * @return the list of string symbols
     * @throws IllegalArgumentException if the level is less than 0
     */
    public List expansionForLevel(int level) {
	if (level < 0)
	    throw new IllegalArgumentException
		("Recursion level "+level+" impossible!");
	if (level < cachedExpansions.size())
	    return (List) cachedExpansions.get(level);
	List lastOne = (List) cachedExpansions.get(cachedExpansions.size()-1);
	for (int i=cachedExpansions.size(); i<=level; i++)
	    cachedExpansions.add(lastOne = expand(lastOne));
	return lastOne;
    }

    /**
     * Does the expansion of a given string list thing.
     * @param symbols the list of symbols to expand
     * @return the expansion of the passed in symbols
     */
    private List expand(List symbols) {
	List ne = new ArrayList();
	Iterator it = symbols.iterator();
	while (it.hasNext()) {
	    String s = (String) it.next();
	    List[] replacements = lsystem.getReplacements(s);
	    List replacement = null;
	    switch (replacements.length) {
	    case 0:
		// This cannot be replaced, so we skip to the next symbol.
		ne.add(s);
		continue;
	    case 1:
		// There is only one replacement possibility.
		replacement = replacements[0];
		break;
	    default:
		// If there's more than one possibility, we choose one
		// nearly at random.
		replacement = replacements
		    [stochiastic.nextInt(replacements.length)];
		break;
	    }
	    Iterator it2 = replacement.iterator();
	    while (it2.hasNext()) ne.add(it2.next()); // Add replacements!
	}
	return ne;
    }

    /** The L-system we are expanding. */
    private LSystem lsystem;
    /** For stochiastic l-systemness, this will generate random numbers. */
    private Random stochiastic;
    /** The cached expansions.  At index 0 is the axiom. */
    private List cachedExpansions = new ArrayList();
    /** For generating random seeds. */
    private static final Random RANDOM = new Random();
}
